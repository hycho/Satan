# 스트림 활용.
 - 필터링, 슬라이싱, 매칭에 관해서 알아본다.
 - 검색, 매칭, 리듀싱에 관해서 알아본다.
 - 특정 범위의 숫자와 같은 숫자 스트림 사용.
 - 다중 소스로부터 스트림 만들기
 - 무한스트림에 관해 알아본다.
 
# 필터링과 슬라이싱
 - 필터링 : 스트림 요소를 선택하는 방법
 - 슬라이싱 : 원하는 데이터로 축소 시키는 방법
 
(1) 프리디케이트(predicate)로 필터링 하기
List<Dish> vegetarianMenu = 
	menu.stream()
	.filter(Dish::isVegetarian) // isVegetarian은 boolean을 리턴
	.collect(toList());
	
(2) 고유 요소 필터링
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
	.filter(i-> i % 2 == 0)
	.distinct()	//distinct를 통해서 중복된 데이터를 배재
	.forEach(System.out::println);
	
(3) 스트림 축소
List<Dish> dishes = 
	menu.stream()
	.limit(3)	//limit을 통해서 3개의 요소를 제외한 나머지 요소를 축소 한다.
	.collect(toList());
						
(4) 요소 건너뛰기
List<Dish> dishes = 
	menu.stream()
	.filter(d->d.getCalories() > 300)
	.skip(2)	//skip을 통해서 2건을 건너뛴다.
	.collect(toList());
	
# 매핑	
 - 특정 데이터만 필터링 하는 기능, 예를 들어 SQL의 테이블에서 특정 열만 선택하는 경우를 들 수 있다.
 - map method를 통해서 새로운 요소를 생성한다. 기존의 값을 고치기 보다는 새로운 버전을 만드는 개념이라고 보시면 된다.
 
(1) 스트림의 각 요소에 함수 적용하기.
 - map을 통해서 특정 항목을 추출한다.
 <EX>
 List<String> dishName = menu.stream()
						.map(Dish::getName)
						.collect(toList());
						
 - 예를 들어 컬렉션 안의 text들이 존재한다 이 text들의 length만 추출하고 싶다면? map을 통해서 추출
 <EX>
 List<String> words = Arrays.asList("Java8", "Lambdas", "In", "Action");
 List<Integer> wordLengths = words.stream()
							.map(String::length)
							.collect(toList());						
							
 - 만약 아까의 Dish의 요리 명을 알고 싶다면 map을 통해서 알아 올 수 있다.	
 <EX>
 List<Integer> dishNamesLength = menu.stream()
								.map(Dish::getName)
								.map(String::length)
								.collect(toList());

(2) 스트림 평면화					
 - Arrays.stream : 문자열을 받아서 각각으로 스트림을 생성해준다.
 - flatMap(Arrays.stream) : map(Arrays.stream)같은 경우 각 배열별 데이터를 스트림을 생성한다 즉 ['h','e','l','l','o'] ['w','o','r','l','d'] 이런식으로 stream을 생성하는 반면
                            flatMap(Arrays.stream)같은 경우 기존 배열과 상관없이 스트림의 각각의 값을 다른 스트림으로 만든다. 즉 ['h','e','l','l','o','w','o','r','l','d'] 이렇게 인식을 한다.
 - 숫자 리스트가 주어 졋을때  각 숫자의 제곱근으로 이루어진 리스트를 반환 하시오. 예를 들어 1,2,3,4,5가 주어질 경우 1,4,9,16,25를 반환해야 합니다.
 <EX>
 intList.stream()
	.map(w -> w*w)
	.forEach((Integer a) -> System.out.println(a.toString()));       
 - 두개의 숫자 리스트가 있을 때 모든 숫자 쌍의 리스트를 반환하시오, 예를 들어 두개의 리스트 [1,2,3]과 [3,4]가 주어지면 [(1,3),(1,4),(2,3),(2,4),(3,3),(3,4)]를 반환해야 합니다.
 <EX>
 List<Integer> number1 = Arrays.asList(1,2,3);
 List<Integer> number2 = Arrays.asList(3,4);

 List<Object> pairs = number1.stream()
					.flatMap(i -> number2.stream().map(j -> new int[]{i, j}))
					.collect(toList());

 int[] a = (int[]) pairs.get(0);
 for(int c : a){
	System.out.println(c);
 }
 - 위의 예제에서 합이 3으로 나누어 떨어지는 쌍만 환환하려면 어떻게 해야할까요? 
 List<Integer> number1 = Arrays.asList(1,2,3);
 List<Integer> number2 = Arrays.asList(3,4);

 List<Object> pairs = number1.stream()
					.flatMap(i -> number2.stream().filter(j -> (i+j)%3 == 0).map(j -> new int[]{i, j}))
					.collect(toList());

 int[] a = (int[]) pairs.get(0);
 for(int c : a){
	System.out.println(c);
 }
 
# 검색과 매칭
 - 특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리에도 스트림은 자주 사용된다. 검색과 매칭에 대해서 allMatch. anyMatch, noneMatch, findFirst, findAny등 다양한 유틸리티 메서드를 지원한다.
 <anyMatch> 
 // anyMatch같은 경우는 주어진 스트림에서 1개의 요소라도 일치함을 확인 할때 쓸 수 있습니
 if(menu.stream().anyMatch(Dish::isVegetarian)) {
	System.out.println("야채가 존재 합니다.");
 }
 
 
 <AllMatch>
 // allMatch메서드는 anyMatch와 달리 스트림의 모든 요소가 주어진 프리디케이트와 일치하는지 검사한다.
 // 모두다 주어진 프리디케이트를 통과해야 true아니면 false
 if(menu.stream().allMatch(d->d.getCalories() < 1000)){
	System.out.println("모두다 건강식");
 } 
 
 <noneMatch>
 //noneMatch는 주어진 요소중에서 predicate와 일치하는 요소가 없는지 체크한다, allMatch과 반대라고 보시면 된다.
 if(menu.stream().noneMatch(d->d.getCalories() > 1000)){
	System.out.println("제길 난 기름진 음식이 먹고 싶어.");
 }
 
 - 위에서 테스트 해본 anyMatch, allMatch, noneMatch 세가지 메서드는 스트림쇼트서킷 이라는 기법, 즉 자바의 &&, ||과 같은 연산을 활용한다.
 - 쇼트 서킷이란 스트림의 모든 요소를 처리 할 필요없이 현재 생성된 결과를 바탕으로 결과를 결정하는 것이라 할 수 있다. 모든 요소를 처리 할 필요없이 주어진 크기의 스트림을 생성하는 limit도 쇼트 서킷 연산이다.
 
<findAny>
//filter와 findAny를 사용해서 채식 요리들을 뽑을 수 있다.
//findAny는 optional<T>를 반환한다 optional은 README를 참조 
Optional<Dish> dish = menu.stream()
							.filter(Dish::isVegetarian)
							.findAny();

<findFirst>
//findfirst를 통해서 1번째 데이터 반환
List<Integer> someNumbers = Arrays.asList(1,2,3,4,5);
Optional<Integer> firstSquareDivisibleByThree = 
		someNumbers.stream()
		.map(x -> x * x)
		.filter(x -> x % 3 == 0)
		.findFirst();
		
System.out.println(firstSquareDivisibleByThree.get());

# 잠깐 Optional에 관해서 간략히 알아보자
 -Optional<T> 클래스(Java.util.Optional)은 값의 존재나 부재 여부를 표현하는 컨테이너 클래스이다. 차후 10장에서 자세히 설명한다.
 -isPresent() : Optional이 값을 포함하면 참(true) 포함하지 않으면 거짓(false)을 반환한다.
 -ifPresent(Consumer<T> block)은 값이 있으면 주어진 로직을 실행
 -T get()은 값이 존재하면 반환, 없으면 NoSuchElementException을 발생.
 -T orElse(T other)는 값이 있으면 값을 반환, 없으면 기본값을 반환한다.

# FindFirst와 findAny는 언제 사용하나?
 - findFirst나 findAny 두 메서드가 왜 필요할까? 병렬성때문이라 한다. 병렬실행에서는 첫번째 요소를 찾기가 매우 힘들다. 만약 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny를 사용하길 바란다.
 
# 리듀싱
 - 리듀싱 : 모든 스트림 요소를 처리 해서 값으로 도출 하는 작업
 - BinalyOperation을 통해서 연산 데이터를 반환한다.
 - 아래는 List값을 for문, reduce를 사용한 방법에 대해서 간략히 정리했다. 
<EX>
int sum = 0;
for(int x : numbers) {
	sum += x;
}
// reduce첫번째 파라메터는 초기값, 2번째는 BinalyOperation<T>이다.
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
int sum1 = numbers.stream().reduce(0, Integer::sum);	//Integer Sum static 메소드 제공
int multiply = numbers.stream().reduce(1, (a, b) -> a * b);

// 초기값을 받지 않는 reduce도 있다 이것은 Optional<T>를 반환한다. 만약 스트림에 아무요소도 없을 경우 초기값이 없으므로 reduce는 연산결과를 반환할 수 없다. 그래서 연산 결과가 없음을 가르킬 수 있도록 Optional 객체로 감싸서 반환한다.
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));

# 최대/최소값
