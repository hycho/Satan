# 람다란 무엇인가?
 - 메서드로 전달할 수 있는 익명함수를 단순화한 것 이라고 말할 수 있다.
 
# 특징
- 익명
 : 보통의 메서드와 달리 이름이 없으므로 익명 이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
- 함수
 : 람다는 메서드 처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라메터 리스트, 바디, 반환형식, 가능한 예외 리스트를 포함한다.
- 전달
 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 할 수 있다.
- 간결성
 : 익명 클래스처럼 많은 짜잘한 코드를 구현할 필요가 없다.
  
람다를 통해서 JAVA8이전에 할 수 없었던 일을 할 수 있는게 아니다.
할 수 있던 일을 간결하게 해주며 익명클래스등 판에 박혀있던 불필요한 코드를 작성할 필요가 없어졌다.

람다 표현식의 예제 및 구성요소는 example01을 참고 하시기 바란다.

람다는 함수형 인터페이스라는 문맥에서 람다 표현식을 사용 할 수 잇다.

함수형 인터페이스?
- 오직 하나의 추상 메서드만 지정하는 인터페이스라 할 수 있다.

java.util.Comparator, java.lang.Runnable같은 것이다.

##########################################
# Quiz01 다음 중 함수형 인터페이스는 무엇인가?
##########################################
(1)
public interface Adder {
	int add(int a, int b);
} 

(2)
public interface SmartAdder extends Adder {
	int add(double a, double b);
}

(3)
public interface Nothing {
}

정답은 1번이다.

함수형 인터페이스로 뭘 할 수 있을까?
 - 람다 표현식으로 인터페이스의 추상 메서드의 기능을 구현 해서 전달이 가능하니, {전체 표현식을 함수형 인터페이스의 인스턴스로 취급} 할 수 있다.
 
# 함수 디스크립터(function descriptor) 먼가 애매모호하게 설명됨... 중요한건 함수형 인터페이스 추상 메소드 시그너처와 람다식의 시그너처는 동일 해야 한다는 것이다.
함수형 인터페이스의 추상 메서드 시그너처(Signature)는 람다 표현식의 시그너처를 가르킨다. 람다 표현식의 시그너처를 서술하는 메서드를 함수 디스크립터라 한다.
예를 들어 람다의 () -> {}는 파라메터가 없으며 void를 반환하는 함수를 의미한다. 즉 Runnable의 run메소드의 시그너처와 동일하다고 이야기 할 수 있다.

# 시그너처란 메소드의 리턴 타입, 파라메터수/타입/위치등을 한대 묶어서 시그너처라고 이야기 한다.

@FunctionalInterface
java.lang.Runnable소스를 보면 @FunctionalInterface어노테이션이 새로 추가가 되어있다.
이어노테이션은 함수형 인터페이스임을 가르키는 어노테이션이며 이 인터페이스를 선언햇지만 함수형 인터페이스가 아닐경우 컴파일러가 에러를 발생한다.
예를들어 추상메소드가 2개 이상이면 "Multiple nonoverrinding abstract methods found in interface Foo(인터페이스 Foo안에 오버라이드 하지 않은 여러 추상메소드가 있다)라는 에러가 발생 할 수 있다.
@FunctionalInterface
public interface Runnable {